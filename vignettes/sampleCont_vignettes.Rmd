---
title: "Sample Contamination"
author: "Lai Ping Wong <laiping.wong@roswellpark.org>"
date: '`r Sys.Date()`'
output:
  pdf_document:
    number_sections: yes
    toc: yes
  html_vignette:
    fig_caption: yes
  html_document:
    toc: yes
vignette: |
  %\VignetteIndexEntry{Sample Contamination} %\VignetteEngine{knitr::rmarkdown} %\VignetteEncoding{UTF-8}
---
\centering
\raggedright
\newpage
\setcounter{section}{0}

# Introduction
sampleCont R package predicts sample contamination base on variant allele frequency (VAF) discovered from genome sequencing of cancer samples. It requires one configuration file and two input data files  

* configuration file  
* variant allele frequency, n x m data frame  (VAF.out)
* variant coverage, n x m data frame (VAFcov.out)

An example of VAF, VAFcov data and its configuration file are distributed with this package under inst/extdata/.

```{r include = FALSE}
library(sampleCont)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(dev = 'pdf') 
```

# Installation
To install this package:
```r
install_github("sampleCont", quick=TRUE)
library(sampleCont)
```

# Quick start single R command line execution
```{r, echo=TRUE,eval= FALSE}
data_path <-  system.file('extdata',package='sampleCont')
output_path <- output_express
config_file <- system.file("extdata", 'config.txt',
    package = "sampleCont", mustWork = TRUE)

run_sampleContamination(data_path = data_path, 
                        output_path = output_path, 
                        config_file = config_file)

```

# Step by step execution 
The purpose of this section is to provide users a step by step workflow of the sample contamination prediction using test data distributed with the package.

## Setup parameters 
```{r,echo=TRUE}
config_file <-  system.file("extdata", 'config.txt',
    package = "sampleCont", mustWork = TRUE)
data_path <- system.file('extdata',package='sampleCont')
output_path <- paste0(getwd() ,'/output')

# set parameters
setParameterConfig(config_file)

# set VAF and COV data file
vaf_file <- paste0(data_path,"/VAF.out")
cov_file <- paste0(data_path,"/VAF_cov.out")

```

## Load VAF data
```r
VAFdata <- inputData(vaf_file) # VAF
head(VAFdata)
```

```{r, echo=FALSE, results='asis'}
VAFdata <- inputData(vaf_file) ## VAF
panderOptions( 'table.caption.prefix' ,"")
panderOptions( 'table.continues.affix',"")
pandoc.table(head(VAFdata),caption ="")
dir.create(file.path(output_path))
dir.create(file.path(paste0(output_path,'/tmp')))

```

## Load COV data
```r
VAFcov <- inputData(cov_file) # COV
head(VAFcov)
```

```{r, echo=FALSE, results='asis'}
VAFcov <- inputData(cov_file) ## VAF
panderOptions( 'table.caption.prefix' ,"")
panderOptions( 'table.continues.affix',"")
pandoc.table(head(VAFcov),caption ="")
```


## Calculate number of SNPs for each sample 
```r
SNPcount <- numMutationperSample(VAFdata,VAF_cutoff,n_sample)
SNPcount
```

```{r, echo=FALSE, results='asis'}
SNPcount <- numMutationperSample(VAFdata,VAF_cutoff,n_sample)
knitr::kable(t(SNPcount),col.names = 'numMut')
```

## Count number of common SNPs for pairwise sample
```r
SNPshare<- pairShare(VAFdata,VAF_cutoff,n_sample)
SNPshare
```

```{r, echo=FALSE, results='asis'}
SNPshare<- pairShare(VAFdata,VAF_cutoff,n_sample)
panderOptions( 'table.caption.prefix' ,"")
panderOptions( 'table.continues.affix',"")
pandoc.table(SNPshare,caption ="")
```

## Predict sample contamination

```{r,echo=TRUE}
# set sample IDs
sampleID <- colnames(VAFcov)[-1]

# calculate pcomm 
pcomm <- pairPCommon(VAFdata,VAF_cutoff,num_round_digit,n_sample)

# tabulate all pairwise samples
pairs <- pairList(VAFdata,n_sample,delimeter)

# generate sample pairs info
pids <- t(sapply(as.matrix(pairs), function(i) unlist(strsplit(i, delimeter))))
colnames(pids) <- c("pid1", "pid2")
sample_pairs <- data.frame(pairID = pairs, pids)

# count number of mutation in 7 regions of VAF scatter plot
countPoint <- regionCountMutation(sample_pairs, VAFdata,
                                  SNPcount, SNPshare,
                                  VAF_cutoff, VAF_ignore, n_sample)
sample_pairs <- cbind(sample_pairs, countPoint)

# identify relation 
rel <- pairRelation(sample_pairs,center_cutoff,source_cutoff,
                    target_cutoff,localPcomm_cutoff,region_cutoff,
                    num_round_digit,output_path)
sample_pairs <- cbind(sample_pairs, rel)


# eliminate multi-sources contamination by using Fisher test
final_rel <- as.data.frame(multipleSource(sample_pairs,VAFdata ,VAFcov,VAF_cutoff,
                                          VAF_cutoff1,p.val_cutoff,output_path))

# calculate mixing ratio for contamination pairs
mr <- as.data.frame(mixingRatio(VAFdata,VAFcov,sample_pairs,
                                final_rel,VAF_cutoff,VAF_ignore,FALSE,output_path))

# filter multi-source contamination by min distance to the predicted contamination level
# weighted with min coverage 
mr_filt <- as.matrix(unique(cbind(source=mr$source,target=mr$target,
                                  predicted_contamination_perc=
                                    as.numeric(mr[,'lm_coeff'])*100)))

final.pred <- as.data.frame(filterMultiSources(mr_filt,output_path,
                                               VAFdata,VAFcov,uniq_both = 2))

# plot circos
same.subject <- sample_pairs[sample_pairs$rel=="00",]
mr_df <- as.data.frame(cbind(mr[,'source'],mr[,'target'],
                             as.numeric(mr[,'lm_coeff'])*100,
                             mr[,'rel'],mr[,'flip']))
colnames(mr_df) <- c('source','target','predicted_contamination_perc','rel','flip')

# attach relation
tmp = unique(merge(mr_df, final.pred, by=c('source','target'))[1:4])
tmp = tmp[order(tmp$rel,decreasing=T),]

contaminate <- tmp[!duplicated(tmp[,c('source','target',
                                      'predicted_contamination_perc.x')]),]
colnames(contaminate) <- c('source','target','link','rel')
contaminate$link <-as.numeric(contaminate$link)/10 # circos link weightage
contaminate[contaminate$rel=='01','rel'] <- '10'

if(nrow(same.subject)>0){
  same.subject.mr <- as.data.frame(mixingRatio(VAFdata,VAFcov,
                                               sample_pairs,final_rel,VAF_cutoff,
                                               VAF_ignore, ALL_flag = TRUE,
                                               sameSubject=TRUE))
  
  same.subject.out <- as.data.frame(cbind(source=same.subject.mr$source,
                                          target=same.subject.mr$target,
                                          link=round(10* 
                                                     as.numeric(same.subject.mr$lm_coeff),
                                                     num_round_digit),
                                          rel=same.subject.mr$rel))
  circos.plot<- as.data.frame(rbind(same.subject.out,contaminate))
}else{
  circos.plot<- contaminate
}

plot_circos_link ( circos.plot,R=220,W=12,plotsize=800,titleStr="",
                   seg.lab.size = 0.7,fig.file="circos.pdf",
                   contaminatedOnly=TRUE,sameSubjectOnly=TRUE,allSamples=sampleID, 
                   output_path )

```

```{r, echo=FALSE}
unlink(paste0(output_path,'/tmp'),recursive = TRUE)
```
\newpage

# Sample contamination prediction output
Output consists of two text files and a circos figure at the designated output_path  

* allPairRelation.txt
* conPred.txt
* circos.pdf


```{r, echo=FALSE, results='asis'}
relTab<- read.table(paste0(output_path,'/allPairRelation.txt'),header=T)
knitr::kable(relTab,caption='allPairRelation')
contTab<- read.table(paste0(output_path,'/contPredict.txt'),header = T)
knitr::kable(contTab,caption='contPredict')
```

```{r, out.width = "1200px" ,echo =FALSE,fig.cap="Circos. Each color section of the circos plot represents sample. Grey links show same subject pairs, source sample color link to target sample. Thickness of link indicates the predicted contaminatoin level. " ,fig.align='center'}
figF<-paste0(output_path,'/','circos.pdf')
knitr::include_graphics(figF)
```

